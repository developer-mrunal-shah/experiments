<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Car Combat: Easy Drive (Top-Down)</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #111; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; }
  canvas { display: block; cursor: crosshair; }
  #ui {
    position: fixed; top: 0; left: 0; right: 0;
    display: flex; justify-content: space-between; align-items: center;
    padding: 10px 20px; pointer-events: none; z-index: 10;
  }
  .score-panel {
    padding: 8px 18px; border-radius: 8px; font-size: 20px; font-weight: bold;
    color: #fff; text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
  }
  #blue-score { background: rgba(30, 100, 220, 0.85); }
  #red-score { background: rgba(220, 40, 40, 0.85); }
  #info {
    background: rgba(0,0,0,0.7); color: #ccc; padding: 6px 14px;
    border-radius: 8px; font-size: 13px; text-align: center;
  }
  #powers-bar {
    position: fixed; bottom: 12px; left: 12px;
    display: flex; gap: 8px; z-index: 10; pointer-events: none;
  }
  .power-icon {
    width: 44px; height: 44px; border-radius: 8px; display: flex;
    flex-direction: column; align-items: center; justify-content: center;
    font-size: 18px; color: #fff; font-weight: bold;
    border: 2px solid rgba(255,255,255,0.3); position: relative;
    text-shadow: 1px 1px 3px #000;
  }
  .power-icon .timer-bar {
    position: absolute; bottom: 0; left: 0; height: 4px; border-radius: 0 0 6px 6px;
  }
  .power-icon .label { font-size: 8px; font-weight: normal; margin-top: 1px; }
  #start-screen {
    position: fixed; inset: 0; background: rgba(0,0,0,0.92);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 100; color: #fff;
  }
  #start-screen h1 {
    font-size: 52px; margin-bottom: 4px;
    background: linear-gradient(90deg, #4af, #4f4);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  }
  #start-screen .subtitle {
    color: #6f6; margin-bottom: 20px; font-size: 18px; font-weight: bold;
  }
  #start-screen .controls {
    background: rgba(255,255,255,0.08); border-radius: 12px; padding: 16px 26px;
    margin-bottom: 16px; text-align: left; font-size: 13px; color: #ccc; line-height: 1.9;
  }
  #start-screen .controls span { color: #fff; font-weight: bold; }
  #start-screen .powers-info {
    background: rgba(200,100,255,0.1); border: 1px solid rgba(200,100,255,0.3);
    border-radius: 8px; padding: 12px 20px; margin-bottom: 16px;
    color: #c8f; font-size: 12px; max-width: 440px; text-align: left; line-height: 1.7;
  }
  #start-screen .powers-info b { color: #fff; }
  .diff-section {
    margin-bottom: 20px; text-align: center;
  }
  .diff-section label {
    color: #aaa; font-size: 14px; display: block; margin-bottom: 10px;
  }
  .diff-buttons { display: flex; gap: 10px; justify-content: center; }
  .diff-btn {
    padding: 10px 24px; font-size: 16px; font-weight: bold;
    border: 2px solid; border-radius: 8px; cursor: pointer;
    background: transparent; transition: all 0.15s;
  }
  .diff-btn:hover { transform: scale(1.05); }
  .diff-btn.easy { color: #4f4; border-color: #4f4; }
  .diff-btn.easy.selected { background: #4f4; color: #000; }
  .diff-btn.medium { color: #fa0; border-color: #fa0; }
  .diff-btn.medium.selected { background: #fa0; color: #000; }
  .diff-btn.hard { color: #f44; border-color: #f44; }
  .diff-btn.hard.selected { background: #f44; color: #000; }
  #start-btn {
    padding: 14px 50px; font-size: 22px; font-weight: bold;
    background: linear-gradient(135deg, #4f4, #2a2); color: #fff;
    border: none; border-radius: 10px; cursor: pointer;
    transition: transform 0.15s;
  }
  #start-btn:hover { transform: scale(1.05); }
  #respawn-msg {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    color: #fff; font-size: 28px; font-weight: bold; text-shadow: 2px 2px 8px #000;
    display: none; z-index: 50; text-align: center; pointer-events: none;
  }
  #minimap {
    position: fixed; bottom: 12px; right: 12px; border: 2px solid rgba(255,255,255,0.3);
    border-radius: 6px; z-index: 10; background: rgba(0,0,0,0.6);
  }
  #pickup-msg {
    position: fixed; top: 30%; left: 50%; transform: translateX(-50%);
    color: #fff; font-size: 22px; font-weight: bold; text-shadow: 2px 2px 6px #000;
    pointer-events: none; z-index: 20; opacity: 0; transition: opacity 0.3s;
    text-align: center;
  }
</style>
</head>
<body>
<div id="start-screen">
  <h1>CAR COMBAT</h1>
  <div class="subtitle">Easy Drive Edition (Top-Down)</div>
  <div class="controls">
    <span>W / Up Arrow</span> — Drive toward your mouse cursor<br>
    <span>S / Down Arrow</span> — Reverse<br>
    <span>A / Left Arrow</span> — Steer Left (manual)<br>
    <span>D / Right Arrow</span> — Steer Right (manual)<br>
    <span>Mouse</span> — Aim turret + steering direction<br>
    <span>Left Click</span> — Shoot &nbsp; <span>Space</span> — Boost &nbsp; <span>R</span> — Reload
  </div>
  <div class="powers-info">
    <b>Special Power Pickups:</b><br>
    <b style="color:#0ff">&#9889; Auto-Reload</b> — Unlimited ammo, no reloading for 10s<br>
    <b style="color:#f0f">&#9731; Shield</b> — Take 75% less damage for 8s<br>
    <b style="color:#f80">&#9733; Rapid Fire</b> — Shoot 3x faster for 8s<br>
    <b style="color:#0f0">&#9752; Speed Boost</b> — 50% faster movement for 10s
  </div>
  <div class="diff-section">
    <label>Choose Difficulty:</label>
    <div class="diff-buttons">
      <button class="diff-btn easy selected" data-diff="easy">EASY</button>
      <button class="diff-btn medium" data-diff="medium">MEDIUM</button>
      <button class="diff-btn hard" data-diff="hard">HARD</button>
    </div>
  </div>
  <button id="start-btn">LET'S GO!</button>
</div>

<div id="ui">
  <div id="blue-score" class="score-panel">BLUE: 0</div>
  <div id="info">
    <div id="hp-text">HP: 250</div>
    <div id="ammo-text">AMMO: 30 / 30</div>
    <div id="boost-text">BOOST: 100%</div>
  </div>
  <div id="red-score" class="score-panel">RED: 0</div>
</div>

<div id="powers-bar"></div>
<div id="respawn-msg"></div>
<div id="pickup-msg"></div>
<canvas id="game"></canvas>
<canvas id="minimap" width="180" height="180"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const miniCanvas = document.getElementById('minimap');
const miniCtx = miniCanvas.getContext('2d');

// ---- DIFFICULTY SETTINGS ----
const DIFFICULTIES = {
  easy: {
    worldSize: 2500,
    playerHp: 250, enemyHp: 55, bulletDmg: 18, enemyBulletDmg: 4,
    reloadTime: 45, enemyFireCooldown: 18, fireCooldown: 5,
    obstacleCount: 20, winScore: 20,
    aimAssist: 0.12, autoSteer: 0.06, turnRate: 0.07,
    enemyTurnSpeed: 0.025, enemyMaxSpeed: 2.0, enemyAimSpeed: 0.035,
    enemyAccuracy: 0.22, enemyFireRange: 350,
    powerDuration: 1.0, // multiplier on power-up durations
    powerSpawnRate: 0.008
  },
  medium: {
    worldSize: 2800,
    playerHp: 180, enemyHp: 80, bulletDmg: 15, enemyBulletDmg: 8,
    reloadTime: 55, enemyFireCooldown: 13, fireCooldown: 6,
    obstacleCount: 28, winScore: 25,
    aimAssist: 0.06, autoSteer: 0.05, turnRate: 0.06,
    enemyTurnSpeed: 0.035, enemyMaxSpeed: 2.8, enemyAimSpeed: 0.05,
    enemyAccuracy: 0.15, enemyFireRange: 420,
    powerDuration: 0.75,
    powerSpawnRate: 0.006
  },
  hard: {
    worldSize: 3000,
    playerHp: 140, enemyHp: 100, bulletDmg: 12, enemyBulletDmg: 12,
    reloadTime: 65, enemyFireCooldown: 10, fireCooldown: 7,
    obstacleCount: 35, winScore: 30,
    aimAssist: 0, autoSteer: 0.04, turnRate: 0.055,
    enemyTurnSpeed: 0.04, enemyMaxSpeed: 3.5, enemyAimSpeed: 0.065,
    enemyAccuracy: 0.1, enemyFireRange: 500,
    powerDuration: 0.5,
    powerSpawnRate: 0.004
  }
};

let difficulty = 'easy';
let CFG = DIFFICULTIES.easy;

// Difficulty selector
document.querySelectorAll('.diff-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('selected'));
    btn.classList.add('selected');
    difficulty = btn.dataset.diff;
    CFG = DIFFICULTIES[difficulty];
  });
});

// Constants that don't change with difficulty
const CAR_W = 40, CAR_H = 24;
const BULLET_SPEED = 13, BULLET_LIFE = 80;
const MAX_AMMO = 30;
const BOOST_MAX = 150, BOOST_DRAIN = 0.4, BOOST_REGEN = 0.5;
const TEAM_SIZE = 5;
const ACCEL = 0.25, BRAKE = 0.2, MAX_SPEED = 4.0, REVERSE_MAX = 2.5;
const COAST_FRICTION = 0.94, DRIVE_FRICTION = 0.985;

// Power-up types
const POWER_TYPES = {
  autoReload:  { label: 'AUTO-RELOAD',  icon: '\u26A1', color: '#0ff', bg: 'rgba(0,255,255,0.2)', duration: 600 },
  shield:      { label: 'SHIELD',       icon: '\u2744', color: '#f0f', bg: 'rgba(255,0,255,0.2)',  duration: 480 },
  rapidFire:   { label: 'RAPID FIRE',   icon: '\u2733', color: '#f80', bg: 'rgba(255,136,0,0.2)',  duration: 480 },
  speedBoost:  { label: 'SPEED BOOST',  icon: '\u2618', color: '#0f0', bg: 'rgba(0,255,0,0.2)',    duration: 600 }
};
const POWER_KEYS = Object.keys(POWER_TYPES);

let W, H;
function resize() { W = canvas.width = innerWidth; H = canvas.height = innerHeight; }
resize();
addEventListener('resize', resize);

// Input
const keys = {};
let mouseX = 0, mouseY = 0, mouseDown = false;
addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; keys[e.code] = true; if (e.key === ' ') e.preventDefault(); });
addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; keys[e.code] = false; });
addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
addEventListener('mousedown', e => { if (e.button === 0) mouseDown = true; });
addEventListener('mouseup', e => { if (e.button === 0) mouseDown = false; });

// Game state
let cars = [], bullets = [], particles = [], pickups = [];
let scores = { blue: 0, red: 0 };
let camera = { x: 0, y: 0 };
let gameStarted = false, gameOver = false, winTeam = '';
let obstacles = [];
let lastPlayerHp = 0;
let damageFlashTimer = 0;
let pickupMsgTimer = 0;

function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
function angleTo(a, b) { return Math.atan2(b.y - a.y, b.x - a.x); }
function rectCollide(x, y, hw, hh, ox, oy, ow, oh) {
  return x - hw < ox + ow && x + hw > ox && y - hh < oy + oh && y + hh > oy;
}

function generateObstacles() {
  obstacles = [];
  let WS = CFG.worldSize;
  for (let i = 0; i < CFG.obstacleCount; i++) {
    let w = 40 + Math.random() * 100;
    let h = 40 + Math.random() * 100;
    let x = 150 + Math.random() * (WS - 300 - w);
    let y = 150 + Math.random() * (WS - 300 - h);
    if ((x < 600 && y < 600) || (x + w > WS - 600 && y + h > WS - 600)) continue;
    obstacles.push({ x, y, w, h, color: `hsl(${Math.random()*40+15}, 20%, ${18 + Math.random()*12}%)` });
  }
}

function spawnPickup() {
  if (pickups.length > 15) return;
  let WS = CFG.worldSize;
  let rand = Math.random();
  let type;
  if (rand < 0.40) type = 'health';
  else if (rand < 0.65) type = 'ammo';
  else {
    // Special power pickup
    type = 'power';
  }
  pickups.push({
    x: 150 + Math.random() * (WS - 300),
    y: 150 + Math.random() * (WS - 300),
    type: type,
    powerType: type === 'power' ? POWER_KEYS[Math.floor(Math.random() * POWER_KEYS.length)] : null,
    timer: 0
  });
}

function spawnPowerPickup() {
  if (pickups.length > 15) return;
  let WS = CFG.worldSize;
  pickups.push({
    x: 150 + Math.random() * (WS - 300),
    y: 150 + Math.random() * (WS - 300),
    type: 'power',
    powerType: POWER_KEYS[Math.floor(Math.random() * POWER_KEYS.length)],
    timer: 0
  });
}

function createCar(team, isPlayer) {
  let WS = CFG.worldSize;
  let x, y;
  if (team === 'blue') { x = 100 + Math.random() * 350; y = 100 + Math.random() * 350; }
  else { x = WS - 450 + Math.random() * 350; y = WS - 450 + Math.random() * 350; }
  let hp = isPlayer ? CFG.playerHp : (team === 'red' ? CFG.enemyHp : CFG.playerHp * 0.7);
  return {
    x, y, angle: Math.random() * Math.PI * 2,
    turretAngle: 0, vx: 0, vy: 0, speed: 0,
    hp: hp, maxHp: hp,
    team, isPlayer,
    ammo: MAX_AMMO, reloading: 0, fireCooldown: 0,
    boost: BOOST_MAX, boosting: false,
    alive: true, respawnTimer: 0,
    // Power-ups (timers in frames)
    powers: { autoReload: 0, shield: 0, rapidFire: 0, speedBoost: 0 },
    ai: isPlayer ? null : {
      targetId: -1, wanderAngle: Math.random() * Math.PI * 2,
      wanderTimer: 0, state: 'wander'
    }
  };
}

function initGame() {
  cars = []; bullets = []; particles = []; pickups = [];
  scores = { blue: 0, red: 0 };
  gameOver = false;
  generateObstacles();
  cars.push(createCar('blue', true));
  for (let i = 1; i < TEAM_SIZE; i++) cars.push(createCar('blue', false));
  for (let i = 0; i < TEAM_SIZE; i++) cars.push(createCar('red', false));
  for (let i = 0; i < 5; i++) spawnPickup();
  for (let i = 0; i < 3; i++) spawnPowerPickup();
  lastPlayerHp = CFG.playerHp;
}

function respawnCar(car) {
  let WS = CFG.worldSize;
  let x, y;
  if (car.team === 'blue') { x = 100 + Math.random() * 350; y = 100 + Math.random() * 350; }
  else { x = WS - 450 + Math.random() * 350; y = WS - 450 + Math.random() * 350; }
  car.x = x; car.y = y;
  car.hp = car.maxHp;
  car.alive = true;
  car.ammo = MAX_AMMO; car.reloading = 0; car.boost = BOOST_MAX;
  car.vx = 0; car.vy = 0; car.speed = 0;
  car.powers = { autoReload: 0, shield: 0, rapidFire: 0, speedBoost: 0 };
}

function showPickupMsg(text, color) {
  let el = document.getElementById('pickup-msg');
  el.innerHTML = `<span style="color:${color}">${text}</span>`;
  el.style.opacity = 1;
  pickupMsgTimer = 90;
}

function fireBullet(car) {
  let hasAutoReload = car.powers.autoReload > 0;
  let hasRapidFire = car.powers.rapidFire > 0;
  let cooldown = car.isPlayer ? CFG.fireCooldown : CFG.enemyFireCooldown;
  if (hasRapidFire && car.isPlayer) cooldown = Math.max(2, Math.floor(cooldown / 3));

  if (!hasAutoReload && (car.ammo <= 0 || car.reloading > 0)) return;
  if (car.fireCooldown > 0) return;

  if (!hasAutoReload) car.ammo--;
  car.fireCooldown = cooldown;
  let a = car.turretAngle;

  // Aim assist for player
  if (car.isPlayer && CFG.aimAssist > 0) {
    let nearest = null, nearDist = Infinity;
    for (let c of cars) {
      if (c.team === car.team || !c.alive) continue;
      let d = dist(car, c);
      if (d < nearDist && d < 500) { nearDist = d; nearest = c; }
    }
    if (nearest) {
      let aimAngle = angleTo(car, nearest);
      let diff = aimAngle - a;
      while (diff > Math.PI) diff -= Math.PI * 2;
      while (diff < -Math.PI) diff += Math.PI * 2;
      if (Math.abs(diff) < 0.35) a += diff * CFG.aimAssist;
    }
  } else if (!car.isPlayer) {
    a += (Math.random() - 0.5) * CFG.enemyAccuracy;
  }

  let bx = car.x + Math.cos(a) * 28;
  let by = car.y + Math.sin(a) * 28;
  let dmg = (car.team === 'red' && !car.isPlayer) ? CFG.enemyBulletDmg : CFG.bulletDmg;
  bullets.push({
    x: bx, y: by,
    vx: Math.cos(a) * BULLET_SPEED + car.vx * 0.3,
    vy: Math.sin(a) * BULLET_SPEED + car.vy * 0.3,
    team: car.team, life: BULLET_LIFE, dmg: dmg
  });
  for (let i = 0; i < 4; i++) {
    particles.push({
      x: bx, y: by,
      vx: Math.cos(a + (Math.random()-0.5)*0.8) * (2+Math.random()*3),
      vy: Math.sin(a + (Math.random()-0.5)*0.8) * (2+Math.random()*3),
      life: 8 + Math.random()*6, maxLife: 14, size: 3+Math.random()*3,
      color: car.team === 'blue' ? '#6cf' : '#fa4'
    });
  }
}

function explode(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    let a = Math.random() * Math.PI * 2;
    let s = 1 + Math.random() * 5;
    particles.push({
      x, y, vx: Math.cos(a)*s, vy: Math.sin(a)*s,
      life: 20+Math.random()*25, maxLife: 45,
      size: 2+Math.random()*6, color
    });
  }
}

function updateAI(car) {
  if (!car.alive || !car.ai) return;
  let ai = car.ai;
  let WS = CFG.worldSize;
  let nearest = null, nearDist = Infinity;
  for (let c of cars) {
    if (c.team === car.team || !c.alive) continue;
    let d = dist(car, c);
    if (d < nearDist) { nearDist = d; nearest = c; }
  }
  let nearPickup = null, pickDist = Infinity;
  if (car.hp < car.maxHp * 0.4) {
    for (let p of pickups) {
      if (p.type !== 'health') continue;
      let d = dist(car, p);
      if (d < pickDist) { pickDist = d; nearPickup = p; }
    }
  }
  let targetX, targetY;
  if (nearPickup && pickDist < 400) {
    targetX = nearPickup.x; targetY = nearPickup.y;
    ai.state = 'pickup';
  } else if (nearest && nearDist < (car.team === 'red' ? 550 : 650)) {
    ai.state = 'combat';
    targetX = nearest.x; targetY = nearest.y;
  } else {
    if (car.team === 'red') {
      ai.state = 'advance';
      targetX = 200 + Math.random() * 400;
      targetY = 200 + Math.random() * 400;
    } else {
      ai.state = 'wander';
      ai.wanderTimer--;
      if (ai.wanderTimer <= 0) {
        ai.wanderAngle = Math.random() * Math.PI * 2;
        ai.wanderTimer = 60 + Math.random() * 120;
      }
      targetX = car.x + Math.cos(ai.wanderAngle) * 300;
      targetY = car.y + Math.sin(ai.wanderAngle) * 300;
    }
  }
  let desiredAngle = angleTo(car, { x: targetX, y: targetY });
  let angleDiff = desiredAngle - car.angle;
  while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
  while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
  let ts = car.team === 'red' ? CFG.enemyTurnSpeed : 0.035;
  car.angle += clamp(angleDiff, -ts, ts);
  let maxSpd = car.team === 'red' ? CFG.enemyMaxSpeed : 3.0;
  let accel = ai.state === 'combat' && nearDist < 200 ? 0.05 : 0.1;
  car.speed = clamp(car.speed + accel, -2, ai.state === 'combat' ? maxSpd : 2.0);
  car.boosting = ai.state === 'combat' && nearDist > 300 && nearDist < 600 && car.boost > 20;
  if (nearest) {
    let aim = angleTo(car, nearest);
    let tDiff = aim - car.turretAngle;
    while (tDiff > Math.PI) tDiff -= Math.PI * 2;
    while (tDiff < -Math.PI) tDiff += Math.PI * 2;
    let as = car.team === 'red' ? CFG.enemyAimSpeed : 0.06;
    car.turretAngle += clamp(tDiff, -as, as);
    let fireRange = car.team === 'red' ? CFG.enemyFireRange : 500;
    if (Math.abs(tDiff) < 0.18 && nearDist < fireRange) fireBullet(car);
  }
  if (car.ammo <= 0 && car.reloading <= 0) car.reloading = CFG.reloadTime;
  if (car.x < 100) car.angle += 0.05;
  if (car.x > WS - 100) car.angle -= 0.05;
  if (car.y < 100) car.angle += 0.05;
  if (car.y > WS - 100) car.angle -= 0.05;
}

function updatePowers(car) {
  for (let key of POWER_KEYS) {
    if (car.powers[key] > 0) car.powers[key]--;
  }
}

function updateCar(car) {
  if (!car.alive) {
    car.respawnTimer--;
    if (car.respawnTimer <= 0) {
      respawnCar(car);
      if (car.isPlayer) document.getElementById('respawn-msg').style.display = 'none';
    }
    return;
  }

  updatePowers(car);

  if (car.isPlayer) {
    let worldMX = mouseX + camera.x - W/2;
    let worldMY = mouseY + camera.y - H/2;
    let mouseAngle = Math.atan2(worldMY - car.y, worldMX - car.x);
    car.turretAngle = mouseAngle;

    let manualSteer = false;
    if (keys['a'] || keys['ArrowLeft']) { car.angle -= CFG.turnRate; manualSteer = true; }
    if (keys['d'] || keys['ArrowRight']) { car.angle += CFG.turnRate; manualSteer = true; }

    let spdMax = car.powers.speedBoost > 0 ? MAX_SPEED * 1.5 : MAX_SPEED;

    if (keys['w'] || keys['ArrowUp']) {
      if (!manualSteer) {
        let steerDiff = mouseAngle - car.angle;
        while (steerDiff > Math.PI) steerDiff -= Math.PI * 2;
        while (steerDiff < -Math.PI) steerDiff += Math.PI * 2;
        car.angle += clamp(steerDiff * CFG.autoSteer * 2, -0.08, 0.08);
      }
      car.speed = clamp(car.speed + ACCEL, -REVERSE_MAX, spdMax);
    } else if (keys['s'] || keys['ArrowDown']) {
      car.speed = clamp(car.speed - BRAKE, -REVERSE_MAX, spdMax);
    } else {
      car.speed *= COAST_FRICTION;
      if (Math.abs(car.speed) < 0.1) car.speed = 0;
    }

    car.boosting = keys[' '] && car.boost > 0;

    // Auto-reload: if power active, ammo is unlimited; otherwise auto-reload when empty
    if (car.powers.autoReload > 0) {
      car.ammo = MAX_AMMO;
      car.reloading = 0;
    } else {
      if (car.ammo <= 0 && car.reloading <= 0) car.reloading = CFG.reloadTime;
      if (keys['r'] && car.ammo < MAX_AMMO && car.reloading <= 0) car.reloading = CFG.reloadTime;
    }

    if (mouseDown) fireBullet(car);
  } else {
    updateAI(car);
  }

  if (car.boosting && car.boost > 0) {
    car.speed *= 1.04;
    car.boost -= BOOST_DRAIN;
    if (Math.random() < 0.5) {
      particles.push({
        x: car.x - Math.cos(car.angle)*20 + (Math.random()-0.5)*10,
        y: car.y - Math.sin(car.angle)*20 + (Math.random()-0.5)*10,
        vx: -Math.cos(car.angle)*2+Math.random()-0.5,
        vy: -Math.sin(car.angle)*2+Math.random()-0.5,
        life: 10+Math.random()*8, maxLife: 18,
        size: 4+Math.random()*4, color: '#f80'
      });
    }
  } else {
    car.boost = Math.min(BOOST_MAX, car.boost + BOOST_REGEN);
  }

  car.fireCooldown = Math.max(0, car.fireCooldown - 1);
  if (car.reloading > 0) { car.reloading--; if (car.reloading <= 0) car.ammo = MAX_AMMO; }

  car.vx = Math.cos(car.angle) * car.speed;
  car.vy = Math.sin(car.angle) * car.speed;
  car.x += car.vx; car.y += car.vy;

  if (car.isPlayer && (keys['w'] || keys['ArrowUp'] || keys['s'] || keys['ArrowDown'])) {
    car.speed *= DRIVE_FRICTION;
  } else if (!car.isPlayer) {
    car.speed *= 0.98;
  }

  let WS = CFG.worldSize;
  car.x = clamp(car.x, 30, WS - 30);
  car.y = clamp(car.y, 20, WS - 20);

  for (let obs of obstacles) {
    if (rectCollide(car.x, car.y, CAR_W/2, CAR_H/2, obs.x, obs.y, obs.w, obs.h)) {
      let cx = obs.x + obs.w/2, cy = obs.y + obs.h/2;
      let dx = car.x - cx, dy = car.y - cy;
      let ang = Math.atan2(dy, dx);
      car.x += Math.cos(ang) * 4; car.y += Math.sin(ang) * 4;
      car.speed *= 0.4;
    }
  }

  for (let i = pickups.length - 1; i >= 0; i--) {
    if (dist(car, pickups[i]) < 35) {
      let pk = pickups[i];
      if (pk.type === 'health') {
        car.hp = Math.min(car.maxHp, car.hp + 60);
      } else if (pk.type === 'ammo') {
        car.ammo = Math.min(MAX_AMMO, car.ammo + 15);
      } else if (pk.type === 'power' && car.isPlayer) {
        let pt = pk.powerType;
        let dur = Math.floor(POWER_TYPES[pt].duration * CFG.powerDuration);
        car.powers[pt] = dur;
        showPickupMsg(`${POWER_TYPES[pt].icon} ${POWER_TYPES[pt].label}!`, POWER_TYPES[pt].color);
        explode(pk.x, pk.y, POWER_TYPES[pt].color, 20);
        pickups.splice(i, 1);
        continue;
      } else if (pk.type === 'power') {
        // AI picks up power but gets a simpler benefit
        car.hp = Math.min(car.maxHp, car.hp + 30);
      }
      explode(pk.x, pk.y, pk.type === 'health' ? '#0f0' : (pk.type === 'ammo' ? '#ff0' : '#f0f'), 10);
      pickups.splice(i, 1);
    }
  }
}

function update() {
  if (!gameStarted || gameOver) return;
  let player = cars[0];
  lastPlayerHp = player.hp;

  for (let car of cars) updateCar(car);

  if (player.alive && player.hp < lastPlayerHp) {
    damageFlashTimer = 15;
  }
  if (damageFlashTimer > 0) damageFlashTimer--;
  if (pickupMsgTimer > 0) {
    pickupMsgTimer--;
    if (pickupMsgTimer <= 0) document.getElementById('pickup-msg').style.opacity = 0;
  }

  let WS = CFG.worldSize;
  for (let i = bullets.length - 1; i >= 0; i--) {
    let b = bullets[i];
    b.x += b.vx; b.y += b.vy; b.life--;
    if (b.life <= 0 || b.x < 0 || b.x > WS || b.y < 0 || b.y > WS) {
      bullets.splice(i, 1); continue;
    }
    let hitObs = false;
    for (let obs of obstacles) {
      if (b.x > obs.x && b.x < obs.x+obs.w && b.y > obs.y && b.y < obs.y+obs.h) {
        explode(b.x, b.y, '#888', 4);
        bullets.splice(i, 1); hitObs = true; break;
      }
    }
    if (hitObs) continue;
    for (let car of cars) {
      if (!car.alive || car.team === b.team) continue;
      if (dist(b, car) < 22) {
        let dmg = b.dmg;
        if (car.powers.shield > 0) dmg = Math.floor(dmg * 0.25);
        car.hp -= dmg;
        // Shield spark effect
        if (car.powers.shield > 0) {
          explode(b.x, b.y, '#f0f', 4);
        }
        explode(b.x, b.y, b.team === 'blue' ? '#4af' : '#f44', 6);
        bullets.splice(i, 1);
        if (car.hp <= 0) {
          car.alive = false; car.respawnTimer = 150;
          scores[b.team]++;
          explode(car.x, car.y, car.team === 'blue' ? '#48f' : '#f44', 30);
          explode(car.x, car.y, '#fa0', 20);
          if (car.isPlayer) {
            let msg = document.getElementById('respawn-msg');
            msg.innerHTML = 'DESTROYED!<br><span style="font-size:18px">Respawning in 2.5s...</span>';
            msg.style.display = 'block';
          }
          if (scores[b.team] >= CFG.winScore) { gameOver = true; winTeam = b.team; }
        }
        break;
      }
    }
  }

  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vx *= 0.96; p.vy *= 0.96;
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Regular pickups
  if (Math.random() < 0.015) spawnPickup();
  // Extra power pickups
  if (Math.random() < CFG.powerSpawnRate) spawnPowerPickup();

  if (player.alive) {
    camera.x += (player.x - camera.x) * 0.1;
    camera.y += (player.y - camera.y) * 0.1;
  }

  // UI
  document.getElementById('blue-score').textContent = `BLUE: ${scores.blue}`;
  document.getElementById('red-score').textContent = `RED: ${scores.red}`;
  if (player.alive) {
    document.getElementById('hp-text').textContent = `HP: ${Math.ceil(player.hp)}`;
    if (player.powers.autoReload > 0) {
      document.getElementById('ammo-text').textContent = `AMMO: UNLIMITED`;
    } else {
      document.getElementById('ammo-text').textContent = player.reloading > 0
        ? `RELOADING... ${Math.ceil(player.reloading/CFG.reloadTime*100)}%`
        : `AMMO: ${player.ammo} / ${MAX_AMMO}`;
    }
    document.getElementById('boost-text').textContent = `BOOST: ${Math.round(player.boost)}%`;
  }

  // Powers bar
  updatePowersBar(player);
}

function updatePowersBar(player) {
  let bar = document.getElementById('powers-bar');
  let html = '';
  if (!player.alive) { bar.innerHTML = ''; return; }
  for (let key of POWER_KEYS) {
    let t = player.powers[key];
    if (t <= 0) continue;
    let pt = POWER_TYPES[key];
    let maxDur = Math.floor(pt.duration * CFG.powerDuration);
    let pct = (t / maxDur) * 100;
    let secs = Math.ceil(t / 60);
    html += `<div class="power-icon" style="background:${pt.bg};border-color:${pt.color}">
      ${pt.icon}
      <div class="label">${secs}s</div>
      <div class="timer-bar" style="width:${pct}%;background:${pt.color}"></div>
    </div>`;
  }
  bar.innerHTML = html;
}

// ---- DRAWING ----

function drawCar(car) {
  if (!car.alive) return;
  ctx.save();
  ctx.translate(car.x - camera.x + W/2, car.y - camera.y + H/2);

  // Shadow
  ctx.save();
  ctx.globalAlpha = 0.3;
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(3, 3, CAR_W/2+2, CAR_H/2+2, car.angle, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // Shield glow
  if (car.powers.shield > 0) {
    ctx.save();
    ctx.globalAlpha = 0.2 + Math.sin(Date.now() * 0.01) * 0.1;
    ctx.strokeStyle = '#f0f';
    ctx.lineWidth = 3;
    ctx.shadowColor = '#f0f';
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.arc(0, 0, CAR_W/2 + 8, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  // Speed boost trail
  if (car.powers.speedBoost > 0 && Math.abs(car.speed) > 1) {
    ctx.save();
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#0f0';
    ctx.shadowColor = '#0f0';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(-Math.cos(car.angle)*18, -Math.sin(car.angle)*18, 6, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // Car body
  ctx.save();
  ctx.rotate(car.angle);
  let bodyColor = car.team === 'blue'
    ? (car.isPlayer ? '#2878ee' : '#3066bb')
    : '#cc3333';
  let darkColor = car.team === 'blue'
    ? (car.isPlayer ? '#1a5ab8' : '#234f8a')
    : '#992222';

  ctx.fillStyle = '#222';
  ctx.fillRect(-CAR_W/2+2, -CAR_H/2-2, 12, 5);
  ctx.fillRect(-CAR_W/2+2, CAR_H/2-3, 12, 5);
  ctx.fillRect(CAR_W/2-14, -CAR_H/2-2, 12, 5);
  ctx.fillRect(CAR_W/2-14, CAR_H/2-3, 12, 5);

  ctx.fillStyle = bodyColor;
  ctx.beginPath();
  ctx.roundRect(-CAR_W/2, -CAR_H/2, CAR_W, CAR_H, 4);
  ctx.fill();
  ctx.strokeStyle = darkColor;
  ctx.lineWidth = 1.5;
  ctx.stroke();

  ctx.fillStyle = 'rgba(150,200,255,0.4)';
  ctx.fillRect(CAR_W/2-14, -CAR_H/2+4, 8, CAR_H-8);

  ctx.fillStyle = car.team === 'blue' ? '#5af' : '#f66';
  ctx.globalAlpha = 0.6;
  ctx.fillRect(-CAR_W/2+3, -2, CAR_W-6, 4);
  ctx.globalAlpha = 1;
  ctx.restore();

  // Turret — glow when rapid fire active
  ctx.save();
  ctx.rotate(car.turretAngle);
  if (car.powers.rapidFire > 0) {
    ctx.shadowColor = '#f80';
    ctx.shadowBlur = 10;
  }
  ctx.fillStyle = car.powers.rapidFire > 0 ? '#c60' : '#555';
  ctx.fillRect(0, -3, 28, 6);
  ctx.fillStyle = car.powers.rapidFire > 0 ? '#a40' : '#444';
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(0, 0, 8, 0, Math.PI*2);
  ctx.fill(); ctx.stroke();
  ctx.fillStyle = car.powers.rapidFire > 0 ? '#f80' : '#666';
  ctx.fillRect(24, -4, 6, 8);
  ctx.shadowBlur = 0;
  ctx.restore();

  // HP bar
  if (car.hp < car.maxHp) {
    let bw = 36;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(-bw/2, -CAR_H/2-12, bw, 5);
    let ratio = car.hp / car.maxHp;
    ctx.fillStyle = ratio > 0.5 ? '#4f4' : ratio > 0.25 ? '#fa0' : '#f33';
    ctx.fillRect(-bw/2, -CAR_H/2-12, bw*ratio, 5);
  }

  // Player indicator
  if (car.isPlayer) {
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(0, -CAR_H/2-18, 4, 0, Math.PI*2);
    ctx.stroke();
  }

  ctx.restore();
}

function drawSteeringGuide() {
  if (!cars.length) return;
  let player = cars[0];
  if (!player.alive) return;
  let sx = player.x - camera.x + W/2;
  let sy = player.y - camera.y + H/2;

  let aheadDist = 50;
  let ax = sx + Math.cos(player.angle) * aheadDist;
  let ay = sy + Math.sin(player.angle) * aheadDist;
  ctx.strokeStyle = 'rgba(100,200,255,0.2)';
  ctx.lineWidth = 2;
  ctx.setLineDash([4, 4]);
  ctx.beginPath();
  ctx.moveTo(sx + Math.cos(player.angle) * 25, sy + Math.sin(player.angle) * 25);
  ctx.lineTo(ax, ay);
  ctx.stroke();
  ctx.setLineDash([]);

  let chevSize = 6;
  let a = player.angle;
  ctx.fillStyle = 'rgba(100,200,255,0.3)';
  ctx.beginPath();
  ctx.moveTo(ax + Math.cos(a) * chevSize, ay + Math.sin(a) * chevSize);
  ctx.lineTo(ax + Math.cos(a + 2.5) * chevSize, ay + Math.sin(a + 2.5) * chevSize);
  ctx.lineTo(ax + Math.cos(a - 2.5) * chevSize, ay + Math.sin(a - 2.5) * chevSize);
  ctx.closePath();
  ctx.fill();
}

function drawGround() {
  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  ctx.lineWidth = 1;
  let startX = Math.floor((camera.x - W/2) / 80) * 80;
  let startY = Math.floor((camera.y - H/2) / 80) * 80;
  for (let x = startX; x < camera.x + W/2; x += 80) {
    let sx = x - camera.x + W/2;
    ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, H); ctx.stroke();
  }
  for (let y = startY; y < camera.y + H/2; y += 80) {
    let sy = y - camera.y + H/2;
    ctx.beginPath(); ctx.moveTo(0, sy); ctx.lineTo(W, sy); ctx.stroke();
  }
}

function drawObstacles() {
  for (let obs of obstacles) {
    let sx = obs.x - camera.x + W/2;
    let sy = obs.y - camera.y + H/2;
    if (sx + obs.w < -50 || sx > W+50 || sy + obs.h < -50 || sy > H+50) continue;
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.fillRect(sx+4, sy+4, obs.w, obs.h);
    ctx.fillStyle = obs.color;
    ctx.fillRect(sx, sy, obs.w, obs.h);
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    ctx.strokeRect(sx, sy, obs.w, obs.h);
    ctx.strokeStyle = 'rgba(255,255,255,0.04)';
    ctx.beginPath();
    ctx.moveTo(sx+3, sy+3); ctx.lineTo(sx+obs.w-3, sy+3);
    ctx.lineTo(sx+obs.w-3, sy+obs.h-3); ctx.lineTo(sx+3, sy+obs.h-3);
    ctx.closePath(); ctx.stroke();
  }
}

function drawPickups() {
  for (let p of pickups) {
    let sx = p.x - camera.x + W/2;
    let sy = p.y - camera.y + H/2;
    if (sx < -30 || sx > W+30 || sy < -30 || sy > H+30) continue;
    p.timer++;
    let pulse = 1 + Math.sin(p.timer * 0.08) * 0.15;
    ctx.save();
    ctx.translate(sx, sy);
    ctx.scale(pulse, pulse);

    if (p.type === 'power') {
      let pt = POWER_TYPES[p.powerType];
      // Outer glow ring
      ctx.strokeStyle = pt.color;
      ctx.lineWidth = 2;
      ctx.shadowColor = pt.color;
      ctx.shadowBlur = 12;
      ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.stroke();
      // Inner fill
      ctx.fillStyle = pt.bg;
      ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI*2); ctx.fill();
      // Icon
      ctx.shadowBlur = 0;
      ctx.fillStyle = pt.color;
      ctx.font = 'bold 18px Arial';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(pt.icon, 0, 0);
    } else {
      ctx.fillStyle = p.type === 'health' ? 'rgba(0,255,0,0.15)' : 'rgba(255,255,0,0.15)';
      ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = p.type === 'health' ? '#0f0' : '#ff0';
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(p.type === 'health' ? '+' : 'A', 0, 0);
    }
    ctx.restore();
  }
}

function drawBullets() {
  for (let b of bullets) {
    let sx = b.x - camera.x + W/2;
    let sy = b.y - camera.y + H/2;
    if (sx < -10 || sx > W+10 || sy < -10 || sy > H+10) continue;
    ctx.fillStyle = b.team === 'blue' ? '#6cf' : '#f64';
    ctx.shadowColor = b.team === 'blue' ? '#4af' : '#f42';
    ctx.shadowBlur = 8;
    ctx.beginPath(); ctx.arc(sx, sy, 3, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 0.3;
    ctx.beginPath(); ctx.arc(sx-b.vx*0.5, sy-b.vy*0.5, 2, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 0;
  }
}

function drawParticles() {
  for (let p of particles) {
    let sx = p.x - camera.x + W/2;
    let sy = p.y - camera.y + H/2;
    ctx.globalAlpha = p.life / p.maxLife;
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(sx, sy, p.size * (p.life/p.maxLife), 0, Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawBorder() {
  let WS = CFG.worldSize;
  ctx.strokeStyle = '#f44';
  ctx.lineWidth = 3;
  ctx.setLineDash([10, 8]);
  let bx = -camera.x + W/2;
  let by = -camera.y + H/2;
  ctx.strokeRect(bx, by, WS, WS);
  ctx.setLineDash([]);
}

function drawDamageVignette() {
  if (damageFlashTimer <= 0) return;
  let alpha = (damageFlashTimer / 15) * 0.4;
  ctx.save();
  let grad = ctx.createRadialGradient(W/2, H/2, W*0.3, W/2, H/2, W*0.7);
  grad.addColorStop(0, 'transparent');
  grad.addColorStop(1, `rgba(255,0,0,${alpha})`);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);
  ctx.restore();
}

function drawMinimap() {
  let WS = CFG.worldSize;
  let mw = miniCanvas.width, mh = miniCanvas.height;
  let sx = mw / WS, sy = mh / WS;
  miniCtx.clearRect(0, 0, mw, mh);
  miniCtx.fillStyle = 'rgba(20,20,20,0.8)';
  miniCtx.fillRect(0, 0, mw, mh);
  miniCtx.fillStyle = 'rgba(100,100,100,0.5)';
  for (let obs of obstacles) miniCtx.fillRect(obs.x*sx, obs.y*sy, obs.w*sx, obs.h*sy);
  // Power pickups on minimap
  for (let pk of pickups) {
    if (pk.type === 'power') {
      miniCtx.fillStyle = POWER_TYPES[pk.powerType].color;
      miniCtx.beginPath();
      miniCtx.arc(pk.x*sx, pk.y*sy, 2.5, 0, Math.PI*2);
      miniCtx.fill();
    }
  }
  for (let car of cars) {
    if (!car.alive) continue;
    miniCtx.fillStyle = car.isPlayer ? '#fff' : (car.team === 'blue' ? '#48f' : '#f44');
    miniCtx.beginPath();
    miniCtx.arc(car.x*sx, car.y*sy, car.isPlayer ? 4 : 2.5, 0, Math.PI*2);
    miniCtx.fill();
  }
  miniCtx.strokeStyle = 'rgba(255,255,255,0.3)';
  miniCtx.lineWidth = 1;
  miniCtx.strokeRect((camera.x-W/2)*sx, (camera.y-H/2)*sy, W*sx, H*sy);
}

function drawDiffIndicator() {
  ctx.save();
  ctx.fillStyle = difficulty === 'easy' ? '#4f4' : difficulty === 'medium' ? '#fa0' : '#f44';
  ctx.globalAlpha = 0.6;
  ctx.font = 'bold 12px Arial';
  ctx.textAlign = 'left';
  ctx.fillText(difficulty.toUpperCase(), 12, H - 8);
  ctx.restore();
}

function drawGameOver() {
  ctx.fillStyle = 'rgba(0,0,0,0.75)';
  ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = winTeam === 'blue' ? '#4af' : '#f44';
  ctx.font = 'bold 64px Arial';
  ctx.textAlign = 'center';
  ctx.fillText(`${winTeam.toUpperCase()} TEAM WINS!`, W/2, H/2-30);
  ctx.fillStyle = '#fff';
  ctx.font = '24px Arial';
  ctx.fillText(`Blue ${scores.blue} — ${scores.red} Red`, W/2, H/2+20);
  ctx.fillText('Click to play again', W/2, H/2+60);
}

function draw() {
  ctx.fillStyle = '#1a1a1a';
  ctx.fillRect(0, 0, W, H);
  drawGround();
  drawBorder();
  drawObstacles();
  drawPickups();
  drawBullets();
  drawParticles();
  let sorted = [...cars].sort((a,b) => a.y - b.y);
  for (let car of sorted) drawCar(car);
  drawSteeringGuide();
  drawDamageVignette();
  drawMinimap();
  drawDiffIndicator();
  if (gameOver) drawGameOver();
}

function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

document.getElementById('start-btn').addEventListener('click', () => {
  document.getElementById('start-screen').style.display = 'none';
  gameStarted = true;
  initGame();
  camera.x = cars[0].x;
  camera.y = cars[0].y;
});

canvas.addEventListener('click', () => {
  if (gameOver) {
    initGame();
    camera.x = cars[0].x;
    camera.y = cars[0].y;
  }
});

canvas.addEventListener('contextmenu', e => e.preventDefault());
gameLoop();
</script>
</body>
</html>
